---
sidebar: sidebar 
permalink: trident-protect/trident-protect-restore-settings.html 
keywords: trident, protect, restore, data, backup 
summary: 注釈、名前空間設定、およびストレージ オプションを使用して、 Trident保護の復元操作をカスタマイズできます。 
---
= 高度なTrident Protect復元設定を使用する
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
注釈、名前空間設定、ストレージ オプションなどの詳細設定を使用して、特定の要件を満たすように復元操作をカスタマイズできます。



== リストア処理とフェイルオーバー処理時のネームスペースのアノテーションとラベル

リストア処理とフェイルオーバー処理では、デスティネーションネームスペースのラベルとアノテーションがソースネームスペースのラベルとアノテーションと一致するように作成されます。デスティネーションネームスペースに存在しないソースネームスペースのラベルまたはアノテーションが追加され、すでに存在するラベルまたはアノテーションがソースネームスペースの値に一致するように上書きされます。デスティネーションネームスペースにのみ存在するラベルやアノテーションは変更されません。


NOTE: Red Hat OpenShift を使用する場合は、OpenShift 環境における名前空間アノテーションの重要な役割に注意することが重要です。名前空間アノテーションにより、復元されたポッドが OpenShift のセキュリティ コンテキスト制約 (SCC) によって定義された適切な権限とセキュリティ構成に準拠し、権限の問題なくボリュームにアクセスできるようになります。詳細については、 https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/authentication_and_authorization/managing-pod-security-policies["OpenShiftセキュリティコンテキスト制約に関するドキュメント"^] 。

リストアまたはフェイルオーバー処理を実行する前にKubernetes環境変数を設定することで、デスティネーションネームスペースの特定のアノテーションが上書きされないようにすることができます `RESTORE_SKIP_NAMESPACE_ANNOTATIONS`。例：

[source, console]
----
helm upgrade trident-protect --set restoreSkipNamespaceAnnotations=<annotation_key_to_skip_1>,<annotation_key_to_skip_2> --reuse-values
----

NOTE: 復元またはフェイルオーバー操作を実行する場合、 `restoreSkipNamespaceAnnotations` そして `restoreSkipNamespaceLabels` 復元またはフェイルオーバー操作から除外されます。これらの設定が Helm の初期インストール時に構成されていることを確認してください。詳細については、 link:../trident-protect/trident-protect-customize-installation.html#configure-additional-trident-protect-helm-chart-settings["追加のTrident Protect Helm チャート設定を構成する"]。

フラグを指定してHelmを使用してソースアプリケーションをインストールした場合は `--create-namespace`、ラベルキーに特別な処理が行わ `name`れます。Trident保護では、リストアまたはフェイルオーバーのプロセスでこのラベルがデスティネーションネームスペースにコピーされますが、ソースの値がソースネームスペースと一致する場合はデスティネーションネームスペースの値に更新されます。この値がソースネームスペースと一致しない場合、変更なしでデスティネーションネームスペースにコピーされます。



=== 例

次の例は、ソースとデスティネーションのネームスペースを示しています。それぞれにアノテーションとラベルが設定されています。処理の前後のデスティネーションネームスペースの状態、およびデスティネーションネームスペースでアノテーションやラベルを組み合わせたり上書きしたりする方法を確認できます。



==== リストアまたはフェイルオーバー処理の前

次の表に、リストアまたはフェイルオーバー処理を実行する前のソースネームスペースとデスティネーションネームスペースの状態を示します。

[cols="1,2a,2a"]
|===
| ネームスペース | アノテーション | ラベル 


| ネームスペースns-1（ソース）  a| 
* Annotation.one/key："UpdatedValue"
* Annotation.Two/key："true"

 a| 
* 環境=本番
* コンプライアンス= HIPAA
* 名前= ns-1




| ネームスペースns-2（デスティネーション）  a| 
* Annotation.one/key："true"
* annotation.three/key："false"

 a| 
* ロール=データベース


|===


==== リストア処理後

次の表に、リストアまたはフェイルオーバー処理後の例のデスティネーションネームスペースの状態を示します。一部のキーが追加され、一部のキーが上書きされ、 `name`デスティネーションネームスペースに一致するようにラベルが更新されました。

[cols="1,2a,2a"]
|===
| ネームスペース | アノテーション | ラベル 


| ネームスペースns-2（デスティネーション）  a| 
* Annotation.one/key："UpdatedValue"
* Annotation.Two/key："true"
* annotation.three/key："false"

 a| 
* 名前= ns-2
* コンプライアンス= HIPAA
* 環境=本番
* ロール=データベース


|===


== サポートされているフィールド

このセクションでは、復元操作に使用できる追加のフィールドについて説明します。



=== ストレージクラスのマッピング

その `spec.storageClassMapping`属性は、ソース アプリケーションに存在するストレージ クラスからターゲット クラスター上の新しいストレージ クラスへのマッピングを定義します。これは、異なるストレージ クラスを持つクラスター間でアプリケーションを移行する場合や、BackupRestore 操作のストレージ バックエンドを変更する場合に使用できます。

* 例： *

[source, yaml]
----
storageClassMapping:
  - destination: "destinationStorageClass1"
    source: "sourceStorageClass1"
  - destination: "destinationStorageClass2"
    source: "sourceStorageClass2"
----


== サポートされている注釈

このセクションでは、システムのさまざまな動作を設定するためにサポートされているアノテーションの一覧を示します。ユーザーがアノテーションを明示的に設定しない場合、システムはデフォルト値を使用します。

[cols="1,1,3,1"]
|===
| アノテーション | を入力します | 説明 | デフォルト値 


| 保護.trident.netapp.io/データムーバータイムアウト秒 | 文字列 | データ ムーバー操作を停止できる最大時間 (秒単位)。 | 「300」 


| 保護.trident.netapp.io/kopia-content-cache-size-limit-mb | 文字列 | Kopia コンテンツ キャッシュの最大サイズ制限 (メガバイト単位)。 | 「1000」 


| protect.trident.netapp.io/pvc-bind-timeout-sec | 文字列 | 新しく作成されたPersistentVolumeClaims（PVC）が到達するまでの最大待機時間（秒）。 `Bound`操作が失敗する前のフェーズ。すべての復元 CR タイプ (BackupRestore、BackupInplaceRestore、SnapshotRestore、SnapshotInplaceRestore) に適用されます。ストレージ バックエンドまたはクラスターでより多くの時間が必要になることが多い場合は、より高い値を使用します。 | 「1200」（20分） 
|===